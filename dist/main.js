(()=>{"use strict";function t(e){if(e.length<2)return;const l=e.slice(0,e.length/2),r=e.slice(Math.floor(e.length/2-e.length));t(l),t(r);let i=0,h=0,o=0;const n=e;for(;i<l.length&&h<r.length;)l[i]<r[h]?n[o++]=l[i++]:n[o++]=r[h++];for(;i<l.length;i++)n[o++]=l[i];for(;h<r.length;h++)n[o++]=r[h];e=n}class e{constructor(t,e,l){this.value=t||null,this.left=e||null,this.right=l||null}}function l(t,e="",r=!0){null!==t&&(null!==t.right&&l(t.right,`${e}${r?"│   ":"    "}`,!1),console.log(`${e}${r?"└── ":"┌── "}${t.value}`),null!==t.left&&l(t.left,`${e}${r?"    ":"│   "}`,!0))}const r=function(t){const e=[];for(let t=0;t<25;t++)e.push(Math.floor(100*Math.random())+1);return e}(),i=new class{constructor(t){this.array=t,this.sortArray(),this.root=this.buildTree(t)}sortArray(){!function(t){for(let e=0;e<t.length;e++)for(let l=e+1;l<t.length;l++)t[e]===t[l]&&(t.splice(l,1),l--)}(this.array),t(this.array)}buildTree(t){const l=Math.floor(t.length/2),r=t[l];if(t.length<1)return;const i=this.buildTree(t.slice(0,l)),h=this.buildTree(t.slice(l+1));return new e(r,i,h)}insert(t,l=this.root){t!==l.value&&(t<l.value?(null===l.left&&(l.left=new e(t)),this.insert(t,l.left)):l.value<t&&(null===l.right&&(l.right=new e(t)),this.insert(t,l.right)))}delete(t,e=this.root){return t<e.value?(e.left=this.delete(t,e.left),e):e.value<t?(e.right=this.delete(t,e.right),e):t===e.value?null!==e.left&&null!==e.right?(e.left.right=e.right,e=e.left):e=null!==e.left?e.left:null!==e.right?e.right:null:void 0}find(t,e=this.root){return t===e.value||null===e?e:t<e.value?this.find(t,e.left):e.value<t?this.find(t,e.right):void 0}height(t){if(null===t)return 0;const e=this.height(t.left),l=this.height(t.right);return e>l?e+1:l+1}depth(t,e=this.root,l=0){if(null!==t&&null!==e)return t===e?l:t.value<e.value?this.depth(t,e.left,++l):t.value>e.value?this.depth(t,e.right,++l):void 0}levelOrder(t,e=[],l=[],r=this.root){if(null!==r){for(e.push(r.value),l.push(r.left),l.push(r.right),t&&t(r);l.length;){const r=l.shift();this.levelOrder(t,e,l,r)}return t?void 0:e}}inOrder(t=[],e=[],l=this.root){if(null!==l){for(this.inOrder(t,e,l.left),e.push(l.value),this.inOrder(t,e,l.right);e.length>0;)t.push(e.shift());return t}}preOrder(t=[],e=[],l=this.root){if(null!==l){for(e.push(l.value),this.preOrder(t,e,l.left),this.preOrder(t,e,l.right);e.length>0;)t.push(e.shift());return t}}postOrder(t=[],e=[],l=this.root){if(null!==l){for(this.postOrder(t,e,l.left),this.postOrder(t,e,l.right),e.push(l.value);e.length>0;)t.push(e.shift());return t}}isBalanced(t=this.root,e=[]){const l=this.height(t.left),r=this.height(t.right);return l-r<2&&l-r>-2?e.push(1):e.push(0),null!==t.left&&null!==t.right&&(this.isBalanced(t.left,e),this.isBalanced(t.right,e)),e.includes(0)?"Tree is NOT BALANCED.":"Tree is BALANCED."}rebalance(){const t=this.inOrder();this.root=this.buildTree(t)}}(r);console.log(r),l(i.root),console.log(i.isBalanced()),console.log(i.levelOrder()),console.log(i.preOrder()),console.log(i.postOrder()),console.log(i.inOrder()),function(t){for(let t=0;t<6;t++)i.insert(Math.floor(100*Math.random())+101)}(),l(i.root),console.log(i.isBalanced()),i.rebalance(),l(i.root),console.log(i.isBalanced()),console.log(i.levelOrder()),console.log(i.preOrder()),console.log(i.postOrder()),console.log(i.inOrder())})();